#!/usr/bin/env python3
import json
import argparse
import logging
import os
import sys
import requests
import time
from requests.adapters import HTTPAdapter
from requests.packages.urllib3.util.retry import Retry

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)

class SplunkHECClient:
    """Client for sending data to Splunk via HTTP Event Collector (HEC)"""
    
    def __init__(self, hec_url, token, max_batch_size=100, verify_ssl=True, timeout=30):
        """
        Initialize the Splunk HEC client.
        
        Args:
            hec_url (str): Splunk HEC URL (e.g., https://splunk.example.com:8088/services/collector)
            token (str): Splunk HEC token
            max_batch_size (int): Maximum number of events to send in a single request
            verify_ssl (bool): Whether to verify SSL certificates
            timeout (int): Connection timeout in seconds
        """
        self.hec_url = hec_url
        self.token = token
        self.max_batch_size = max_batch_size
        self.verify_ssl = verify_ssl
        self.timeout = timeout
        self.headers = {
            "Authorization": f"Splunk {token}",
            "Content-Type": "application/json"
        }
        
        # Configure session with retries
        self.session = requests.Session()
        retry_strategy = Retry(
            total=5,
            backoff_factor=1,
            status_forcelist=[408, 429, 500, 502, 503, 504],
            allowed_methods=["POST"]
        )
        self.session.mount("https://", HTTPAdapter(max_retries=retry_strategy))
        self.session.mount("http://", HTTPAdapter(max_retries=retry_strategy))
    
    def send_events(self, events):
        """
        Send events to Splunk HEC in batches.
        
        Args:
            events (list): List of event dictionaries to send
            
        Returns:
            tuple: (success, error_count, sent_count)
        """
        if not events:
            logging.warning("No events to send")
            return True, 0, 0
        
        total_events = len(events)
        sent_count = 0
        error_count = 0
        
        # Process events in batches
        for i in range(0, total_events, self.max_batch_size):
            batch = events[i:i + self.max_batch_size]
            batch_size = len(batch)
            
            try:
                # Prepare payload according to Splunk HEC format
                payload = ""
                for event in batch:
                    # Each event needs to be a separate JSON object with 'event' field
                    event_wrapper = {"event": event, "sourcetype": "aqua:security:vulnerability"}
                    payload += json.dumps(event_wrapper) + "\n"
                
                # Send request
                response = self.session.post(
                    self.hec_url,
                    data=payload,
                    headers=self.headers,
                    verify=self.verify_ssl,
                    timeout=self.timeout
                )
                
                if response.status_code not in (200, 201, 204):
                    logging.error(f"Failed to send batch to Splunk. Status: {response.status_code}, Response: {response.text}")
                    error_count += batch_size
                else:
                    sent_count += batch_size
                    logging.info(f"Successfully sent batch of {batch_size} events to Splunk")
                
                # Slight delay to avoid overwhelming Splunk
                if i + self.max_batch_size < total_events:
                    time.sleep(0.1)
                    
            except Exception as e:
                logging.error(f"Error sending batch to Splunk: {str(e)}")
                error_count += batch_size
                
                # Exponential backoff if we encounter errors
                time.sleep(2)
        
        success = error_count == 0
        return success, error_count, sent_count

def send_filtered_report_to_splunk(filtered_file, hec_url, token, batch_size=100, verify_ssl=True):
    """
    Send filtered Aqua vulnerability data to Splunk.
    
    Args:
        filtered_file (str): Path to the Splunk-optimized JSON file (_splunk.json)
        hec_url (str): Splunk HEC URL
        token (str): Splunk HEC token
        batch_size (int): Maximum number of events to send in a single request
        verify_ssl (bool): Whether to verify SSL certificates
        
    Returns:
        bool: True if successful, False otherwise
    """
    try:
        # Check if we have the Splunk-optimized file
        if not os.path.exists(filtered_file):
            logging.error(f"Filtered file not found: {filtered_file}")
            return False
        
        # Load events from the file (one JSON object per line)
        events = []
        with open(filtered_file, 'r') as f:
            for line in f:
                line = line.strip()
                if line:
                    try:
                        event = json.loads(line)
                        events.append(event)
                    except json.JSONDecodeError as e:
                        logging.error(f"Error parsing JSON line: {str(e)}")
        
        if not events:
            logging.warning(f"No events found in {filtered_file}")
            return True
        
        logging.info(f"Loaded {len(events)} events from {filtered_file}")
        
        # Initialize Splunk HEC client
        client = SplunkHECClient(
            hec_url=hec_url, 
            token=token, 
            max_batch_size=batch_size,
            verify_ssl=verify_ssl
        )
        
        # Send events to Splunk
        success, error_count, sent_count = client.send_events(events)
        
        if success:
            logging.info(f"Successfully sent all {sent_count} events to Splunk")
        else:
            logging.warning(f"Sent {sent_count} events to Splunk, but failed to send {error_count} events")
        
        # Write a report file
        report_file = filtered_file.replace('_splunk.json', '_splunk_report.json')
        with open(report_file, 'w') as f:
            report = {
                'timestamp': time.strftime('%Y-%m-%d %H:%M:%S'),
                'file_processed': filtered_file,
                'splunk_hec_url': hec_url.split('/services')[0],  # Don't log the full URL with path
                'total_events': len(events),
                'events_sent': sent_count,
                'events_failed': error_count,
                'success': success
            }
            json.dump(report, f, indent=2)
        
        return success
        
    except Exception as e:
        logging.error(f"Error sending data to Splunk: {str(e)}")
        import traceback
        logging.error(traceback.format_exc())
        return False

def main():
    parser = argparse.ArgumentParser(description='Send Aqua vulnerability data to Splunk')
    parser.add_argument('filtered_file', help='Path to the filtered Splunk-optimized JSON file (_splunk.json)')
    parser.add_argument('--hec-url', required=True, help='Splunk HEC URL (e.g., https://splunk.example.com:8088/services/collector)')
    parser.add_argument('--token', required=True, help='Splunk HEC token')
    parser.add_argument('--batch-size', type=int, default=100, help='Maximum number of events to send in a single request')
    parser.add_argument('--no-verify-ssl', action='store_true', help='Disable SSL certificate verification')
    
    args = parser.parse_args()
    
    success = send_filtered_report_to_splunk(
        args.filtered_file,
        args.hec_url,
        args.token,
        args.batch_size,
        not args.no_verify_ssl
    )
    
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main() 